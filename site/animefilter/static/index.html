<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width">
        <title>Anime Filter (Online &amp;Free) - Painted/Cartoon Converter</title>
        <link id="favicon" rel="icon" href="/animefilter/img/icon.jpg" type="image/jpg">
    </head>
    <body>
        <style>
            :root {
                --text-color: black;
            }

            body {
                color: var(--text-color);
                font-family: sans-serif;
            }

            .dropAreaCtn:hover {
                background: #f3f3f3;
            }

            .titleDotCom:before {
                content: '.com';
            }

            @keyframes spinner {
                to {
                    transform: rotate(360deg);
                }
            }

            .spinner:before {
                content: '';
                box-sizing: border-box;
                position: absolute;
                top: 50%;
                left: 50%;
                width: 20px;
                height: 20px;
                margin-top: -10px;
                margin-left: -10px;
                border-radius: 50%;
                border: 2px solid #ccc;
                border-top-color: #000;
                animation: spinner .6s linear infinite;
            }
        </style>
        <h1 style="text-align:center;">
            Click to Vist Origin Site: 
            <a href="https://animefilter.com" target="_blank">
                Anime<span style="font-size:20%"></span>
                Filter<span class="titleDotCom" style="font-size:60%; opacity:0.5;"></span>
            </a>
        </h1>
        <div class="dropAreaCtn" style="border: 5px dashed lightgrey;color: grey;font-family: sans-serif;height:20vh;position:relative;display:flex;flex-direction:column;align-items:center;justify-content:center; max-width:800px; margin:0 auto;">
            <div>drag &amp;drop an image</div>
            <div style="font-style:italic;">
                <i>— or —</i>
            </div>
            <div>click here to open the file picker</div>
            <input type="file" accept="image/*" oninput="" id="dropZoneInputEl" style="position: absolute;top: 0;left: 0;right: 0;bottom: 0;opacity:0;width: 100%;cursor: pointer;">
        </div>
        <div style="display:flex; flex-wrap:wrap; font-size:80%; margin: 0.125rem; max-width:800px; margin:0.125rem auto;">
            <div style="background: #e7e7e7;display:flex;padding:0.25rem; margin: 0.125rem; border-radius:3px; align-items:center;">
                <input type="checkbox" id="autoCropCheckboxEl" checked style="margin:0;">
                <label for="autoCropCheckboxEl">
                    &nbsp;auto-crop? <span style="opacity:0.6; font-size:90%;">(recommended)</span>
                </label>
            </div>
            <div style="background: #e7e7e7;display:flex;padding:0.25rem; margin: 0.125rem; border-radius:3px; align-items:center;">
                image type:&nbsp;
                <select id="imageTypeSelectEl" style="font-size:80%;">
                    <option>face</option>
                    <option>landscape</option>
                    <option>auto-detect</option>
                </select>
            </div>
        </div>
        <div id="outputEl" style="max-width:800px; margin:0 auto;"></div>
        <div style="max-width:800px; margin:0 auto;">
            <p id="inputHintArrow" style="text-align:center;font-size: 2rem; color: grey;">⬆</p>
            <h2 style="position:fixed; top:-200px;">Anime Filter Online - Photo to Anime Converter</h2>
            <p>
                Use the input area above to submit an image, and it'll output the image in a "painted" style. All processing is done on your device - your image is <i>not</i>
                uploaded to a server - it never leaves your web browser. Make sure your images have good lighting and aren't blurry. Here are some example photo-to-anime/painting conversions created with this tool:
            </p>
            <div style="text-align:center;">
                <img src="/animefilter/img/examples1.jpg" style="height:700px;">
            </div>
            <p>You've probably heard of anime-style filters on Snapchat, Tiktok, and elsewhere (most are "selfie to anime" but there are some more general "photo to anime" converters). This filter produces a more painterly and realistic style compared to others. I called the site "AnimeFilter" because it'll eventually have a collection of converters that are all centered around anime-like styles, but not strictly anime (e.g. cartoon/"toonify" and Disney styles). They'll all be online, free and easy to use so that turning yourself into a painted/anime/cartoon character will be as easy as dropping a selfie and waiting a few seconds.</p>
            <p>
                If you came here looking for an <a href="https://perchance.org/ai-anime-generator" target="_blank">AI anime generator</a>
                , then check out ← that site instead. Or the more general <a href="https://perchance.org/ai-text-to-image-generator" target="_blank">AI Image Generator</a>
                . And, tangentially, <a href="https://perchance.org/anime-recommender" target="_blank">Anime Recommender</a>
                may be useful if you're looking for new anime to watch.
            </p>
            <p>
                <b>Tips:</b>
            </p>
            <ul>
                <li>Right-click or long-press on the output image to save it.</li>
                <li>If you'd prefer a less-realistic (more cartoon-like and painterly), then you can submit an image, then get the output and submit that. You can recursively submit the image until it produces your desired effect. If you re-submit the output too many times it'll get weird :)</li>
                <li>Since the computation is happening on your device, using a faster device (like a laptop instead of a phone) will result in faster processing.</li>
                <li>If you don't use the auto-crop function, and you've selected the "face" image type, then make sure you manually crop the face so that it takes up most of the image and is centered (see examples above). Otherwise the result might look a bit weird.</li>
                <li>You can run multiple conversions at the same time by dropping another image while the previous conversion process is still loading.</li>
            </ul>
            <p>
                If you have feedback, you can share it with me <a href="https://s.surveyplanet.com/rj4tas2n">here</a>
                . If you find another photo-to-anime/toon/etc. converter that you'd like me to add, please share details using that link and I'll see if I can add it (assuming it's using a publicly available AI model).
            </p>
            <p>
                This converter is based on the original <a href="https://huggingface.co/spaces/akhaliq/AnimeGANv2">Hugging Face web demo</a>
                , created by <a href="https://twitter.com/ak92501/">@ak92501</a>
                using the AI model created by <a href="https://github.com/bryandlee/animegan2-pytorch">@bryandlee</a>
                , which uses training techniques developed by <a href="https://github.com/TachibanaYoshino/AnimeGANv2">Xin Chen</a>
                . I created this site so that users can convert their image to an anime/cartoon style without uploading their images to a server - it's completely free. The conversion process is done in your browser (using your device's CPU/GPU) so your images remain private.
            </p>
            <p>Have fun! :)</p>
            <br>
            <br>
            <br>
        </div>
        <script>
            window.OffscreenCanvas || (window.OffscreenCanvas = class OffscreenCanvas {
                constructor(e, t) {
                    return this.canvas = document.createElement("canvas"),
                    this.canvas.width = e,
                    this.canvas.height = t,
                    this.canvas.convertToBlob = () => new Promise(e => {
                        this.canvas.toBlob(e)
                    }
                    ),
                    this.canvas
                }
            }
            ),
            window.createImageBitmap || (window.createImageBitmap = function(a) {
                return new Promise(e => {
                    let t = document.createElement("img");
                    t.onload = e,
                    t.src = URL.createObjectURL(a)
                }
                )
            }
            );
            let alreadyLoggedView = !1;
            document.querySelector("#dropZoneInputEl").oninput = async function() {
                if (this.files[0]) {
                    var e = Date.now()
                      , a = document.querySelector("#autoCropCheckboxEl").checked
                      , o = document.querySelector("#imageTypeSelectEl").value;
                    let t = !1;
                    var i = this.files[0];
                    await processImage(window.theFileToBeProcessed = i).catch(e => {
                        t = !0,
                        alert(`Sorry! There was an error during processing. If you're using an old browser, please try upgrading to a modern browser like Chrome or Edge. Details of the error: ${e.message} ` + e.stack)
                    }
                    );
                    console.log('using time: ' + (Date.now() - e) + ' ms')
                }
            }
            ;
            let ortSessions = {};
            const modelMetas = {
                "AnimeGANv2-FacePortraitV2-512px": {
                    inputName: "input.1",
                    outputName: "940"
                },
                "AnimeGANv2-Paprika-512px": {
                    inputName: "input.1",
                    outputName: "884"
                }
            };
            async function getRgbData(t) {
                let a = [[], [], []];
                var o = t.data;
                for (let e = 0; e < o.length; e += 4) {
                    var i = e / 4 % t.width
                      , r = Math.floor(e / 4 / t.width);
                    a[0][r] || (a[0][r] = []),
                    a[1][r] || (a[1][r] = []),
                    a[2][r] || (a[2][r] = []),
                    a[0][r][i] = o[e + 0] / 255 * 2 - 1,
                    a[1][r][i] = o[e + 1] / 255 * 2 - 1,
                    a[2][r][i] = o[e + 2] / 255 * 2 - 1
                }
                return a = Float32Array.from(a.flat().flat()),
                a
            }
            async function processImage(e) {
                e = e || window.theFileToBeProcessed;
                var t = createPlaceholderEl();
                document.querySelector("#outputEl").prepend(t),
                document.querySelector("#inputHintArrow") && document.querySelector("#inputHintArrow").remove(),
                localStorage.warnedAboutFreeze || (alert("This should take less than 20 seconds, but may take a bit longer if you're using an old/slow device. Please be patient while your image is processed :)"),
                localStorage.warnedAboutFreeze = "1"),
                await new Promise(e => setTimeout(e, 50));
                var a = await createImageBitmap(e);
                document.querySelector("#dropZoneInputEl").value = "";
                let o = new OffscreenCanvas(a.width,a.height)
                  , i = o.getContext("2d");
                i.drawImage(a, 0, 0, o.width, o.height);
                let r = await getLargestFaceCropRegion(o);
                for (var n = !!r, c = document.querySelector("#autoCropCheckboxEl").checked, e = document.querySelector("#imageTypeSelectEl").value; !window.ort; )
                    await new Promise(e => setTimeout(e, 500));
                let s;
                "face" === e || "auto-detect" === e && n ? (ortSessions["AnimeGANv2-FacePortraitV2-512px"] || (ortSessions["AnimeGANv2-FacePortraitV2-512px"] = await ort.InferenceSession.create("/animefilter/models/AnimeGANv2-FacePortraitV2-512px.onnx", {
                    executionProviders: ["wasm"]
                })),
                s = ortSessions["AnimeGANv2-FacePortraitV2-512px"],
                modelMeta = modelMetas["AnimeGANv2-FacePortraitV2-512px"]) : "landscape" !== e && ("auto-detect" !== e || n) || (ortSessions["AnimeGANv2-Paprika-512px"] || (ortSessions["AnimeGANv2-Paprika-512px"] = await ort.InferenceSession.create("/animefilter/models/AnimeGANv2-Paprika-512px.onnx", {
                    executionProviders: ["wasm"]
                })),
                s = ortSessions["AnimeGANv2-Paprika-512px"],
                modelMeta = modelMetas["AnimeGANv2-Paprika-512px"]),
                r && c && "landscape" !== e || (r = {
                    topLeft: [0, 0],
                    width: a.width,
                    height: a.height
                });
                a = i.getImageData(r.topLeft[0], r.topLeft[1], r.width, r.height);
                o.width = r.width,
                o.height = r.height,
                i.putImageData(a, 0, 0);
                let l = new OffscreenCanvas(512,512)
                  , d = l.getContext("2d");
                d.drawImage(o, 0, 0, l.width, l.height);
                a = await getRgbData(d.getImageData(0, 0, l.width, l.height)),
                a = {
                    [modelMeta.inputName]: new ort.Tensor("float32",a,[1, 3, 512, 512])
                };
                displayImageBlob(await rgbResultDataToImageBlob((await s.run(a))[modelMeta.outputName].data, {
                    originalWidth: r.width,
                    originalHeight: r.height
                }), t)
            }
            function rgbResultDataToImageBlob(i, e) {
                var r = 262144;
                let n = [];
                for (let o = 0; o < r; o++) {
                    let e = .5 * i[o] + .5;
                    e = e < 0 ? 0 : 1 < e ? 255 : Math.round(255 * e);
                    let t = .5 * i[o + r] + .5;
                    t = t < 0 ? 0 : 1 < t ? 255 : Math.round(255 * t);
                    let a = .5 * i[o + 2 * r] + .5;
                    a = a < 0 ? 0 : 1 < a ? 255 : Math.round(255 * a),
                    n[4 * o + 0] = e,
                    n[4 * o + 1] = t,
                    n[4 * o + 2] = a,
                    n[4 * o + 3] = 255
                }
                var t = new ImageData(new Uint8ClampedArray(n),512,512);
                let a = new OffscreenCanvas(512,512)
                  , o = a.getContext("2d");
                o.putImageData(t, 0, 0);
                let c = new OffscreenCanvas(e.originalWidth,e.originalHeight);
                return c.getContext("2d").drawImage(a, 0, 0, e.originalWidth, e.originalHeight),
                c.convertToBlob()
            }
            function displayImageBlob(e, t) {
                e = URL.createObjectURL(e);
                let a = t.querySelector("img");
                a.src = e,
                a.style.display = "",
                t.querySelector(".spinner").remove()
            }
            function createPlaceholderEl() {
                let e = document.createElement("div");
                return e.innerHTML = `
      <div style="text-align:center; margin:1rem;">
        <img style="display:none; max-width:100%;" src="">
        <div class="spinner" style="position:relative;"><span style="opacity:0">Loading...</span></div>
      </div>
      `,
                e
            }
            !async function() {
                for (; !window.ort; )
                    await new Promise(e => setTimeout(e, 500));
                ort.env.wasm.numThreads = Math.min(navigator.hardwareConcurrency, 8),
                ort.env.wasm.proxy = !0,
                ortSessions["AnimeGANv2-FacePortraitV2-512px"] = await ort.InferenceSession.create("/animefilter/models/AnimeGANv2-FacePortraitV2-512px.onnx", {
                    executionProviders: ["wasm"]
                })
            }();
            let blazefaceModel;
            async function getLargestFaceCropRegion(imgCanvas) {
                for (; !window.tf || !window.blazeface || !blazefaceModel; )
                    await new Promise(e => setTimeout(e, 500));
                let iW = imgCanvas.width
                  , iH = imgCanvas.height
                  , unscaleFactor = 1;
                for (; 2e3 < Math.max(iW, iH); )
                    iW /= 2,
                    iH /= 2,
                    unscaleFactor *= 2;
                let canvasTmp = new OffscreenCanvas(iW,iH);
                canvasTmp.getContext("2d").drawImage(imgCanvas, 0, 0, canvasTmp.width, canvasTmp.height);
                const returnTensors = !1
                  , predictions = await blazefaceModel.estimateFaces(canvasTmp, returnTensors)
                  , hasFace = 0 < predictions.length;
                if (0 < predictions.length) {
                    predictions.forEach(e => e.mainFaceScore = (e.bottomRight[0] - e.topLeft[0]) * (e.bottomRight[1] - e.topLeft[1]) * e.probability[0]),
                    predictions.sort( (e, t) => t.mainFaceScore - e.mainFaceScore);
                    let mainFace = predictions[0]
                      , rightEye = mainFace.landmarks[0]
                      , leftEye = mainFace.landmarks[1]
                      , middle = [(leftEye[0] + rightEye[0]) / 2, (leftEye[1] + rightEye[1]) / 2]
                      , eyeDist = Math.sqrt((leftEye[0] - rightEye[0]) ** 2 + (leftEye[1] - rightEye[1]) ** 2)
                      , crop = {
                        topLeft: [(middle[0] - 2 * eyeDist) * unscaleFactor, (middle[1] - 2 * eyeDist) * unscaleFactor],
                        width: 4 * eyeDist * unscaleFactor,
                        height: 4.5 * eyeDist * unscaleFactor
                    };
                    if (window.blazefaceDebug) {
                        var debugCanvas = document.createElement("canvas");
                        debugCanvas.style.maxWidth = "100%",
                        document.querySelector("#outputEl").prepend(debugCanvas),
                        debugCanvas.width = imgCanvas.width,
                        debugCanvas.height = imgCanvas.height;
                        let ctx = debugCanvas.getContext("2d");
                        ctx.drawImage(imgCanvas, 0, 0),
                        ctx.fillStyle = "rgba(255, 0, 0, 0.5)",
                        ctx.fillRect(crop.topLeft[0], crop.topLeft[1], crop.width, crop.height)
                    }
                    if (crop.topLeft[0] < 0 && (crop.topLeft[0] = 0),
                    crop.topLeft[1] < 0 && (crop.topLeft[1] = 0),
                    crop.topLeft[0] + crop.width > imgCanvas.width && (crop.width = imgCanvas.width - crop.topLeft[0]),
                    crop.topLeft[1] + crop.height > imgCanvas.height && (crop.height = imgCanvas.height - crop.topLeft[1]),
                    window.blazefaceDebug) {
                        let ctx = debugCanvas.getContext("2d");
                        ctx.fillStyle = "rgba(0, 0, 255, 0.5)",
                        ctx.fillRect(crop.topLeft[0], crop.topLeft[1], crop.width, crop.height)
                    }
                    return crop
                }
                return console.log("No face."),
                !1
            }
            !async function() {
                for (; !window.tf || !window.blazeface; )
                    await new Promise(e => setTimeout(e, 500));
                blazefaceModel = await blazeface.load({
                    modelUrl: '/animefilter/js/model.json'
                })
            }(),
            window.blazefaceDebug = !1;
        </script>
        <script defer src="/animefilter/js/tf.js"></script>
        <script defer src="/animefilter/js/tf-converter.min.js"></script>
        <script defer src="/animefilter/js/blazeface.js"></script>
        <script async src="/animefilter/js/ort.js"></script>
    </body>
</html>
